# System Architecture Document: Foundry
**Generated by:** Agent 2 - System Architecture v19 (Application-Agnostic)  
**Date:** 2026-01-21  
**Status:** Complete  
**Framework Version:** Agent Specification Framework v2.1  
**Constitution:** Agent 0 - Agent Constitution v3.3

---

## Document Purpose

This architecture translates Foundry's PRD into implementable technical specifications. Every technology choice traces to PRD requirements with explicit trade-offs. Target deployment is Replit with focus on working deployments over theoretical elegance.

---

## 1. Architectural Drivers

### 1.1 Core Requirements from PRD

**Data Processing Pipeline:**
- Multi-format file ingestion (CSV, JSON, XML, XLSX)
- Schema mapping and normalization
- PII detection and de-identification
- Real-time processing with progress tracking
- Dataset export in multiple formats

**Integration Requirements:**
- OAuth integration with Teamwork Desk API
- External file storage (S3-compatible)
- Email service for transactional emails
- PII detection service/library

**Multi-Tenancy:**
- Organization-based isolation
- Role-based access control (Admin, Editor, Viewer)
- Team collaboration features

**Scale Expectations:**
- 50-200 organizations (MVP phase)
- 100k records per processing job
- Processing time: <30 minutes per job
- Concurrent users: 10-50 per organization

### 1.2 Hard Constraints (Constitution Section D)

**Replit Platform:**
- Port 5000 production (exposed port)
- Ephemeral filesystem (database + external storage required)
- Environment via Replit Secrets
- Cold start behavior after inactivity
- No interactive CLI prompts
- Single container deployment

**Database:**
- PostgreSQL via Replit managed DB
- Connection: postgres-js driver (mandated)
- ORM: Drizzle ORM (Core Select API only)
- Connection pooling with caching enabled

### 1.3 Proposed Pattern

**Architecture Style:** Monolithic full-stack with clear layer separation
- Frontend: React SPA with Vite
- Backend: Express.js REST API
- Database: PostgreSQL with Drizzle ORM
- Storage: External S3-compatible service
- Processing: In-process queue with database state tracking

**Rationale:** Monolithic architecture chosen for MVP to minimize operational complexity, enable rapid iteration, and avoid distributed system challenges on Replit's single-container model.

---

## CHECKPOINT 1: Architecture Foundation

**Architectural Drivers:** Multi-tenant SaaS with data processing pipeline, OAuth integrations, file storage, and real-time progress tracking

**Hard Constraints:** Replit deployment (port 5000, ephemeral filesystem, single container), PostgreSQL with postgres-js driver, Drizzle ORM Core Select API only

**Proposed Pattern:** Monolithic full-stack (React + Express + PostgreSQL) with external file storage and in-process job processing

**Eliminated Technologies:** 
- Distributed job queues (Bull, BullMQ) - too complex for single container
- Microservices architecture - operational overhead exceeds MVP needs
- GraphQL - REST simpler for CRUD operations
- MongoDB - PRD requires relational multi-tenancy
- WebSockets for progress - SSE simpler and sufficient

**Continuing to technology selection...**

---

## 2. Technology Stack

### 2.1 Frontend Stack

**Choice:** React 18 + TypeScript + Vite

**Alternatives Considered:**
1. Next.js - Rejected: SSR complexity unnecessary for authenticated SaaS, Replit deployment simpler with SPA
2. Vue.js - Rejected: Team familiarity and ecosystem size favor React
3. Angular - Rejected: Framework complexity exceeds MVP needs

**Rationale:** React provides rich component ecosystem (shadcn/ui), excellent TypeScript support, and Vite enables fast development iterations. SPA architecture simplifies Replit deployment.

**Trade-offs:**
- **Gain:** Fast development, rich ecosystem, type safety, hot reload
- **Sacrifice:** Initial load time vs. SSR, SEO (acceptable for authenticated app)

**UI Framework:** shadcn/ui + Tailwind CSS
- Component library: shadcn/ui (copy-paste components, customizable)
- Styling: Tailwind CSS with CSS variables for theming
- Icons: Lucide React

### 2.2 Backend Stack

**Choice:** Express.js + TypeScript

**Alternatives Considered:**
1. Fastify - Rejected: Performance gains minimal for MVP scale, Express ecosystem larger
2. Nest.js - Rejected: Framework overhead unnecessary, Express sufficient for CRUD API
3. Hono - Rejected: Less mature ecosystem, Express battle-tested

**Rationale:** Express provides mature ecosystem, extensive middleware library, and simple integration with Drizzle ORM. TypeScript adds type safety across full stack.

**Trade-offs:**
- **Gain:** Proven stability, middleware ecosystem, team familiarity
- **Sacrifice:** Raw performance vs. newer frameworks (acceptable for MVP scale)

### 2.3 Database Stack

**Choice:** PostgreSQL 14+ with Drizzle ORM (Core Select API)

**Alternatives Considered:**
1. Prisma - Rejected: Constitution mandates Drizzle ORM
2. TypeORM - Rejected: Constitution mandates Drizzle ORM
3. Raw SQL - Rejected: Type safety and migration tooling valuable

**Rationale:** PostgreSQL provides robust multi-tenancy support (row-level security), JSONB for flexible metadata, and full-text search capabilities. Drizzle ORM mandated by Constitution Section D.

**Driver:** postgres-js (Constitution mandated)
**Connection:** Pool with caching enabled, max 10 connections

**Trade-offs:**
- **Gain:** Relational integrity, ACID transactions, mature tooling
- **Sacrifice:** Learning curve vs. document DB (acceptable for team)

### 2.4 File Storage

**Choice:** AWS S3 (or compatible: Cloudflare R2, Backblaze B2)

**Alternatives Considered:**
1. Replit ephemeral storage - Rejected: Files lost on container restart
2. Database BYTEA - Rejected: Poor performance for large files, expensive
3. Self-hosted MinIO - Rejected: Operational complexity for MVP

**Rationale:** S3-compatible storage provides reliable persistence, scalable storage, and industry-standard API. Cloudflare R2 or Backblaze B2 offer S3 compatibility at lower cost.

**Trade-offs:**
- **Gain:** Reliable persistence, scalable, no operational overhead
- **Sacrifice:** External dependency, cost per GB (acceptable for business model)

**Recommendation:** Start with Cloudflare R2 (zero egress fees) or Backblaze B2 (low cost)

### 2.5 Email Service

**Choice:** Resend

**Alternatives Considered:**
1. SendGrid - Rejected: More expensive, complex UI
2. AWS SES - Rejected: Requires AWS account management, IP warming
3. Self-hosted SMTP - Rejected: Deliverability challenges, operational overhead

**Rationale:** Resend provides simple API, excellent deliverability, generous free tier (100 emails/day), and React Email template support.

**Trade-offs:**
- **Gain:** Simple integration, modern DX, React templates, low cost
- **Sacrifice:** Single vendor dependency (mitigated by standard email APIs)

**Fallback:** Log emails to console in development, gracefully degrade if service unavailable

### 2.6 PII Detection

**Choice:** Custom regex patterns + compromise.js NER

**Alternatives Considered:**
1. Microsoft Presidio - Rejected: Python dependency, complex deployment
2. AWS Comprehend PII - Rejected: External API cost, latency
3. spaCy.js - Rejected: Large model size (100MB+), slow initialization

**Rationale:** compromise.js provides lightweight NER (100KB), runs in Node.js, and custom regex handles deterministic patterns (email, phone, SSN). Combination achieves 85-90% accuracy at <100ms per document.

**Pattern Library:**
- Email addresses: RFC 5322 regex
- Phone numbers: International formats (E.164)
- SSN/National IDs: Country-specific patterns
- Credit cards: Luhn algorithm validation
- Named entities: compromise.js (PERSON, ORG, LOCATION)

**Trade-offs:**
- **Gain:** Fast performance, no external API, no Python runtime
- **Sacrifice:** Accuracy vs. ML models (85-90% vs. 95%+, acceptable for MVP)

### 2.7 Authentication

**Choice:** JWT with bcrypt password hashing

**Alternatives Considered:**
1. Session cookies - Rejected: Stateful, complicates horizontal scaling
2. OAuth-only (no email/password) - Rejected: Vendor lock-in risk
3. Auth0/Clerk - Rejected: External dependency, cost, overkill for MVP

**Rationale:** JWT provides stateless authentication, mobile-friendly, and enables future API access. bcrypt offers industry-standard password hashing with configurable work factor.

**Configuration (per Constitution Section C):**
- Token expiry: 24 hours
- Refresh token: Not implemented in MVP (reevaluate if session expiry issues)
- Password hashing: bcrypt rounds=12

**Trade-offs:**
- **Gain:** Stateless, scalable, standard
- **Sacrifice:** Token revocation complexity (acceptable for MVP)

---

## CHECKPOINT 2: Technology Stack Complete

**Complete Stack:**
- Frontend: React 18 + TypeScript + Vite + shadcn/ui + Tailwind CSS
- Backend: Express.js + TypeScript
- Database: PostgreSQL 14+ with Drizzle ORM (postgres-js driver)
- Storage: S3-compatible (Cloudflare R2 recommended)
- Email: Resend
- PII Detection: compromise.js + custom regex
- Auth: JWT + bcrypt

**Replit Compatibility:** ✓ All technologies verified compatible
- Single container deployment
- Port 5000 exposed
- No interactive CLI tools
- External services via API (S3, email)

**Identified Concerns:**
1. Processing timeout strategy (30-minute limit) - addressed in processing architecture
2. PII detection accuracy (85-90%) - acceptable for MVP, instrument for improvement
3. Email deliverability - Resend provides strong reputation management

**Continuing to component design...**

---

## 3. System Components

### 3.1 Component Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                         CLIENT (BROWSER)                         │
│  React SPA + shadcn/ui + Tailwind CSS + React Router           │
└────────────────────┬────────────────────────────────────────────┘
                     │ HTTPS
                     │ JWT Bearer Token
                     ▼
┌─────────────────────────────────────────────────────────────────┐
│                     EXPRESS.JS API SERVER                        │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │
│  │   Auth       │  │  Projects    │  │  Processing  │         │
│  │  Middleware  │  │   Routes     │  │    Engine    │         │
│  └──────────────┘  └──────────────┘  └──────────────┘         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐         │
│  │   Upload     │  │   Schema     │  │   Export     │         │
│  │   Handler    │  │   Mapper     │  │   Generator  │         │
│  └──────────────┘  └──────────────┘  └──────────────┘         │
└────────┬──────────────────┬──────────────────┬─────────────────┘
         │                  │                  │
         │                  │                  │
         ▼                  ▼                  ▼
┌─────────────────┐ ┌──────────────────┐ ┌────────────────┐
│   PostgreSQL    │ │  S3 Storage      │ │  External APIs │
│   (Drizzle ORM) │ │  (Cloudflare R2) │ │  - Resend      │
│   - Users       │ │  - Raw files     │ │  - Teamwork    │
│   - Orgs        │ │  - Exports       │ │                │
│   - Projects    │ │                  │ │                │
│   - Jobs        │ │                  │ │                │
└─────────────────┘ └──────────────────┘ └────────────────┘
```

### 3.2 Component Responsibilities

**Frontend (React SPA):**
- User authentication UI (login, registration, password reset)
- Project management (create, configure, list)
- File upload with drag-and-drop
- Schema mapping interface (visual column mapper)
- Processing progress monitoring (poll for status updates)
- Data preview and export
- Organization and team management

**API Server (Express.js):**
- Request routing and middleware
- Authentication and authorization
- File upload handling (multipart/form-data)
- Processing job orchestration
- Database operations via Drizzle ORM
- S3 file operations
- Email sending via Resend
- OAuth flow handling (Teamwork Desk)

**Processing Engine (In-Process):**
- Job queue management (database-backed)
- File parsing (CSV, JSON, XML, XLSX)
- PII detection and redaction
- Schema mapping and transformation
- Dataset validation
- Export generation (JSON, CSV, JSONL)
- Progress tracking updates

**Database (PostgreSQL):**
- User accounts and authentication
- Organization multi-tenancy
- Project configuration and state
- Processing jobs and logs
- Schema definitions
- Encrypted OAuth tokens

**External Storage (S3):**
- Uploaded source files (30-day retention)
- Generated dataset exports (30-day retention)
- Temporary processing files

**External Services:**
- Resend: Transactional emails
- Teamwork Desk API: OAuth and data import

### 3.3 Data Flow Patterns

**File Upload Flow:**
1. Client: Upload file via multipart/form-data to `/api/files/upload`
2. Server: Save to /tmp, virus scan, upload to S3, store metadata in DB
3. Server: Return file ID and S3 URL
4. Client: Display upload success, enable processing

**Processing Flow:**
1. Client: Submit processing job with configuration
2. Server: Create job record (status: pending), return job ID
3. Server: Queue job for processing (in-memory or database queue)
4. Processing Engine: Download file from S3, parse, transform, detect PII, export
5. Processing Engine: Update job status in DB (processing → completed/failed)
6. Client: Poll `/api/jobs/:id` for status updates, download on completion

**OAuth Flow (Teamwork Desk):**
1. Client: Click "Connect Teamwork Desk"
2. Server: Redirect to Teamwork OAuth authorization URL
3. User: Authorize on Teamwork
4. Teamwork: Redirect to callback with authorization code
5. Server: Exchange code for tokens, **encrypt tokens**, store in DB
6. Server: Redirect client to success page
7. Client: Begin data import from Teamwork

---

## 4. API Architecture

### 4.1 API Design Principles

**RESTful Design:**
- Resource-oriented URLs (`/api/projects`, `/api/jobs`)
- HTTP verbs for actions (GET, POST, PUT, DELETE)
- HTTP status codes for responses (200, 201, 400, 401, 404, 500)

**Consistency:**
- All endpoints use standardized response envelopes (see Section 6)
- Pagination for list endpoints (page-based)
- ISO 8601 timestamps for all dates
- Request IDs for tracing

### 4.2 Authentication & Authorization

**Authentication:**
- JWT Bearer tokens in Authorization header
- Token generated on login, expires after 24 hours
- No refresh tokens in MVP (reevaluate if needed)

**Authorization:**
- Organization-based isolation (users can only access their org's data)
- Role-based access control (Admin, Editor, Viewer)
- Middleware validates user has required role for action

**Endpoints:**
- POST `/api/auth/register` - Create account
- POST `/api/auth/login` - Login with email/password
- POST `/api/auth/logout` - Logout (client discards token)
- POST `/api/auth/forgot-password` - Request password reset
- POST `/api/auth/reset-password` - Reset password with token
- GET `/api/auth/me` - Get current user info

### 4.3 Core API Endpoints

**Projects:**
- GET `/api/projects` - List user's projects (paginated)
- POST `/api/projects` - Create new project
- GET `/api/projects/:id` - Get project details
- PUT `/api/projects/:id` - Update project configuration
- DELETE `/api/projects/:id` - Delete project

**Files:**
- POST `/api/files/upload` - Upload source file (multipart/form-data)
- GET `/api/files/:id` - Get file metadata
- DELETE `/api/files/:id` - Delete file

**Jobs:**
- POST `/api/jobs` - Create processing job
- GET `/api/jobs/:id` - Get job status and results
- DELETE `/api/jobs/:id` - Cancel job
- GET `/api/projects/:projectId/jobs` - List project jobs

**Exports:**
- GET `/api/exports/:id` - Download processed dataset
- POST `/api/exports/:id/regenerate` - Regenerate export

**Integrations:**
- GET `/api/integrations/teamwork/authorize` - Start OAuth flow
- GET `/api/integrations/teamwork/callback` - OAuth callback
- POST `/api/integrations/teamwork/import` - Import tickets
- DELETE `/api/integrations/teamwork` - Disconnect integration

**Organizations:**
- GET `/api/organizations/me` - Get current organization
- PUT `/api/organizations/me` - Update organization settings
- POST `/api/organizations/members` - Invite team member
- DELETE `/api/organizations/members/:id` - Remove member

### 4.4 Health & Monitoring

**Health Check (per Constitution Section C):**
- GET `/health` - Returns 200 OK with uptime and dependencies

**Format:**
```json
{
  "status": "healthy",
  "timestamp": "2026-01-21T10:30:00Z",
  "uptime": 3600,
  "dependencies": {
    "database": "healthy",
    "storage": "healthy",
    "email": "healthy"
  }
}
```

---

## 5. Processing Architecture

### 5.1 Job Queue Design

**Choice:** Database-backed job queue with in-process worker

**Alternatives Considered:**
1. Bull/BullMQ with Redis - Rejected: Redis not available on Replit free tier, operational complexity
2. External queue service (AWS SQS) - Rejected: External dependency, cost, latency
3. Database-only with polling - Chosen: Simple, reliable, sufficient for MVP scale

**Implementation:**
- Jobs table stores: id, status, progress, configuration, results, errors
- Worker polls for pending jobs every 5 seconds
- Single worker process (Replit single container)
- Job timeout: 30 minutes

**Job States:**
- `pending` - Job created, not started
- `processing` - Job actively running
- `completed` - Job finished successfully
- `failed` - Job encountered error
- `cancelled` - User cancelled job

### 5.2 Processing Pipeline

**Stages:**

1. **File Download** (5-10s)
   - Download file from S3 to /tmp
   - Validate file integrity
   - Update progress: 10%

2. **File Parsing** (10-30s for 100k records)
   - Detect file format (CSV, JSON, XML, XLSX)
   - Parse into memory-efficient stream
   - Validate against expected structure
   - Update progress: 30%

3. **Schema Mapping** (20-60s)
   - Apply user-configured column mappings
   - Transform data to canonical schema
   - Handle missing/null values per rules
   - Update progress: 50%

4. **PII Detection** (60-180s for 100k records)
   - Run compromise.js NER on text fields
   - Apply regex patterns (email, phone, SSN, etc.)
   - Generate PII detection report
   - Update progress: 70%

5. **PII Redaction** (10-20s)
   - Apply user-configured redaction rules
   - Redact detected PII entities
   - Log redaction events for audit
   - Update progress: 80%

6. **Validation** (5-10s)
   - Validate against schema constraints
   - Check required fields present
   - Verify data types
   - Update progress: 90%

7. **Export Generation** (10-30s)
   - Generate requested formats (JSON, CSV, JSONL)
   - Upload to S3
   - Create download URLs
   - Update progress: 100%, status: completed

**Error Handling:**
- Each stage wrapped in try-catch
- Errors logged with stage context
- Job marked `failed` with error details
- Partial results saved if possible

### 5.3 Progress Tracking

**Implementation:**
- Job record in database updated after each stage
- `progress` field: integer 0-100
- `stage` field: enum (downloading, parsing, mapping, detecting_pii, redacting, validating, exporting)
- Client polls `/api/jobs/:id` every 2 seconds for updates

**Response:**
```json
{
  "data": {
    "id": "job-123",
    "status": "processing",
    "progress": 70,
    "stage": "detecting_pii",
    "recordsProcessed": 70000,
    "recordsTotal": 100000,
    "startedAt": "2026-01-21T10:00:00Z"
  }
}
```

### 5.4 Timeout & Cancellation

**Timeout Strategy:**
- Maximum processing time: 30 minutes
- Implemented via setTimeout at job start
- On timeout: Mark job `failed`, log error, cleanup /tmp files

**Cancellation:**
- User can cancel job via DELETE `/api/jobs/:id`
- Set `cancelled` flag in database
- Worker checks flag between stages, stops if true
- Cleanup /tmp files, mark job `cancelled`

**Trade-offs:**
- **Gain:** Prevents runaway jobs, resource protection
- **Sacrifice:** Large datasets may hit timeout (addressed post-MVP with streaming)

---

## 6. Response Envelope Specification

**CRITICAL:** All API responses use standardized envelopes for frontend integration consistency.

### 6.1 Success Response Structure

```typescript
{
  "data": { ... },           // The actual response payload
  "meta": {
    "timestamp": "ISO-8601", // Response generation time
    "requestId": "uuid"      // For request tracing
  }
}
```

**Example:**
```json
{
  "data": {
    "id": "proj-123",
    "name": "Customer Support Dataset",
    "status": "active"
  },
  "meta": {
    "timestamp": "2026-01-21T10:30:00Z",
    "requestId": "req-abc-123"
  }
}
```

### 6.2 Paginated Response Structure

```typescript
{
  "data": [ ... ],           // Array of items
  "meta": {
    "timestamp": "ISO-8601",
    "requestId": "uuid",
    "pagination": {
      "page": 1,             // Current page number (1-indexed)
      "pageSize": 20,        // Items per page
      "total": 100,          // Total items across all pages
      "totalPages": 5,       // Total number of pages
      "hasMore": true        // Whether more pages exist
    }
  }
}
```

**Example:**
```json
{
  "data": [
    { "id": "proj-1", "name": "Dataset 1" },
    { "id": "proj-2", "name": "Dataset 2" }
  ],
  "meta": {
    "timestamp": "2026-01-21T10:30:00Z",
    "requestId": "req-abc-123",
    "pagination": {
      "page": 1,
      "pageSize": 20,
      "total": 42,
      "totalPages": 3,
      "hasMore": true
    }
  }
}
```

### 6.3 Error Response Structure

```typescript
{
  "error": {
    "code": "ERROR_CODE",    // Machine-readable error identifier
    "message": "Human-readable error message",
    "details": { ... }       // Optional additional context
  },
  "meta": {
    "timestamp": "ISO-8601",
    "requestId": "uuid"
  }
}
```

**Example:**
```json
{
  "error": {
    "code": "INVALID_FILE_FORMAT",
    "message": "File must be CSV, JSON, or XLSX format",
    "details": {
      "providedFormat": "pdf",
      "allowedFormats": ["csv", "json", "xlsx"]
    }
  },
  "meta": {
    "timestamp": "2026-01-21T10:30:00Z",
    "requestId": "req-abc-123"
  }
}
```

### 6.4 Response Helper Functions (Mandatory Implementation)

**File:** `server/lib/response.ts`

```typescript
import { Response } from 'express';

export function sendSuccess(res: Response, data: any) {
  return res.json({
    data,
    meta: {
      timestamp: new Date().toISOString(),
      requestId: res.locals.requestId,
    },
  });
}

export function sendCreated(res: Response, data: any) {
  return res.status(201).json({
    data,
    meta: {
      timestamp: new Date().toISOString(),
      requestId: res.locals.requestId,
    },
  });
}

export function sendPaginated(
  res: Response,
  data: any[],
  pagination: {
    page: number;
    pageSize: number;
    total: number;
  }
) {
  const totalPages = Math.ceil(pagination.total / pagination.pageSize);
  const hasMore = pagination.page < totalPages;

  return res.json({
    data,
    meta: {
      timestamp: new Date().toISOString(),
      requestId: res.locals.requestId,
      pagination: {
        page: pagination.page,
        pageSize: pagination.pageSize,
        total: pagination.total,
        totalPages,
        hasMore,
      },
    },
  });
}

export function sendNoContent(res: Response) {
  return res.status(204).send();
}
```

**Usage Example:**
```typescript
// Success response
return sendSuccess(res, { id: project.id, name: project.name });

// Created response
return sendCreated(res, { id: newProject.id });

// Paginated response
return sendPaginated(res, projects, { page: 1, pageSize: 20, total: 42 });

// No content (DELETE)
return sendNoContent(res);
```

**Enforcement:**
- NO direct `res.json()` calls allowed in route handlers
- All responses MUST use helper functions
- Code review checklist includes envelope compliance

---

## 7. Sensitive Data Encryption Specification

**CRITICAL (AUDIT FIX: HIGH-001):** Foundry stores OAuth access tokens and refresh tokens for Teamwork Desk integration. These MUST be encrypted at rest.

### 7.1 Data Requiring Encryption

**OAuth Tokens:**
- Teamwork Desk access tokens
- Teamwork Desk refresh tokens

**Third-Party API Keys (Future):**
- S3 access keys (if stored per-organization)
- Email service API keys (if stored per-organization)

### 7.2 Encryption Algorithm

**Algorithm:** AES-256-GCM (Galois/Counter Mode)

**Configuration:**
- Key Size: 256 bits (32 bytes)
- Initialization Vector (IV): 128 bits (16 bytes, random per encryption)
- Authentication Tag: 128 bits (16 bytes)

**Why AES-256-GCM:**
- Industry standard for symmetric encryption
- Authenticated encryption (prevents tampering)
- Fast performance (~100MB/s)
- Built into Node.js crypto module (no external dependencies)

### 7.3 Encryption Utility Implementation

**File:** `server/lib/encryption.ts`

```typescript
import crypto from 'crypto';

const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16;
const TAG_LENGTH = 16;

// Load encryption key from environment (must be 32 bytes as hex = 64 chars)
const ENCRYPTION_KEY = Buffer.from(process.env.ENCRYPTION_KEY!, 'hex');

if (ENCRYPTION_KEY.length !== 32) {
  throw new Error('ENCRYPTION_KEY must be 64 hex characters (32 bytes)');
}

/**
 * Encrypt text using AES-256-GCM
 * Returns format: iv:encrypted:authTag (all hex-encoded)
 */
export function encrypt(text: string): string {
  const iv = crypto.randomBytes(IV_LENGTH);
  const cipher = crypto.createCipheriv(ALGORITHM, ENCRYPTION_KEY, iv);

  let encrypted = cipher.update(text, 'utf8', 'hex');
  encrypted += cipher.final('hex');

  const authTag = cipher.getAuthTag();

  // Return format: iv:encrypted:authTag (all hex)
  return `${iv.toString('hex')}:${encrypted}:${authTag.toString('hex')}`;
}

/**
 * Decrypt text encrypted with encrypt()
 * Expects format: iv:encrypted:authTag (all hex-encoded)
 */
export function decrypt(encryptedText: string): string {
  const parts = encryptedText.split(':');
  if (parts.length !== 3) {
    throw new Error('Invalid encrypted text format');
  }

  const iv = Buffer.from(parts[0], 'hex');
  const encrypted = parts[1];
  const authTag = Buffer.from(parts[2], 'hex');

  const decipher = crypto.createDecipheriv(ALGORITHM, ENCRYPTION_KEY, iv);
  decipher.setAuthTag(authTag);

  let decrypted = decipher.update(encrypted, 'hex', 'utf8');
  decrypted += decipher.final('utf8');

  return decrypted;
}

/**
 * Generate a new encryption key (for initial setup)
 * Run: node -e "console.log(require('./server/lib/encryption').generateEncryptionKey())"
 */
export function generateEncryptionKey(): string {
  return crypto.randomBytes(32).toString('hex');
}
```

### 7.4 Key Management

**Environment Variable:**
```bash
ENCRYPTION_KEY=[64 hex characters]  # REQUIRED for production
```

**Generation Command:**
```bash
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

**Example Output:**
```
a7f3d8c2b1e9f4d5c6a8b7e2f1d3c4a5b6c7d8e9f1a2b3c4d5e6f7a8b9c1d2e3f4
```

**Startup Validation:**
```typescript
// server/index.ts
if (!process.env.ENCRYPTION_KEY || process.env.ENCRYPTION_KEY.length !== 64) {
  throw new Error('ENCRYPTION_KEY environment variable required (64 hex chars)');
}
```

**Key Rotation Strategy:**
1. Generate new key: `crypto.randomBytes(32).toString('hex')`
2. Deploy code with dual-key support (old + new)
3. Background job: Decrypt all sensitive data with old key, re-encrypt with new key
4. Remove old key from environment
5. Deploy code with new key only

**Key Loss:** If ENCRYPTION_KEY is lost, all encrypted data is **unrecoverable**. 
- **CRITICAL:** Back up key securely (password manager, secrets vault)
- Document key recovery process in runbook

### 7.5 Usage Pattern

**Storing Encrypted Data:**
```typescript
import { encrypt } from '../lib/encryption';

// OAuth callback - store tokens
const encryptedAccessToken = encrypt(oauthTokens.access_token);
const encryptedRefreshToken = encrypt(oauthTokens.refresh_token);

await db.insert(integrations).values({
  userId: user.id,
  organizationId: user.organizationId,
  provider: 'teamwork',
  accessToken: encryptedAccessToken,    // Encrypted before storage
  refreshToken: encryptedRefreshToken,  // Encrypted before storage
  expiresAt: new Date(Date.now() + oauthTokens.expires_in * 1000),
});
```

**Retrieving Encrypted Data:**
```typescript
import { decrypt } from '../lib/encryption';

// Fetch integration and decrypt tokens
const integration = await db.query.integrations.findFirst({
  where: eq(integrations.organizationId, user.organizationId),
});

if (!integration) {
  throw new Error('Teamwork integration not found');
}

const accessToken = decrypt(integration.accessToken);   // Decrypted after retrieval
const refreshToken = decrypt(integration.refreshToken); // Decrypted after retrieval

// Use decrypted tokens for API calls
const tickets = await fetchTeamworkTickets(accessToken);
```

### 7.6 Zero-Tolerance Rule

**NO TODO/FIXME comments allowed in encryption code paths.**

This is a **deployment blocker**:
```typescript
// âœ— DEPLOYMENT BLOCKER
// TODO: Encrypt token before storage
await db.insert(integrations).values({ accessToken: plainToken });
```

This is **acceptable**:
```typescript
// âœ" ACCEPTABLE
if (!process.env.ENCRYPTION_KEY) {
  throw new Error('ENCRYPTION_KEY required for OAuth integrations');
}

const encryptedToken = encrypt(plainToken);
await db.insert(integrations).values({ accessToken: encryptedToken });
```

### 7.7 Database Schema Considerations

Encrypted data stored as **TEXT** column (hex-encoded format: `iv:encrypted:authTag`).

**Example Schema:**
```typescript
export const integrations = pgTable('integrations', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').notNull(),
  organizationId: integer('organization_id').notNull(),
  provider: text('provider').notNull(), // 'teamwork'
  accessToken: text('access_token').notNull(),   // Stores encrypted hex string
  refreshToken: text('refresh_token').notNull(), // Stores encrypted hex string
  expiresAt: timestamp('expires_at').notNull(),
  createdAt: timestamp('created_at').defaultNow().notNull(),
});
```

**Storage Size:**
- IV: 32 hex chars (16 bytes)
- Auth Tag: 32 hex chars (16 bytes)
- Encrypted data: Variable (typically 2x plaintext length)
- Format overhead: 2 colons
- **Total:** ~100-200 chars for typical OAuth token

### 7.8 Architecture Decision Record

**ADR-001: Sensitive Data Encryption**

**Context:** Foundry stores OAuth access tokens and refresh tokens for Teamwork Desk integration. These credentials provide full access to user's Teamwork account and must be protected at rest. Database compromise must not expose plaintext tokens.

**Decision:** Implement AES-256-GCM encryption for all OAuth tokens and third-party API keys before database storage. Encryption key stored in ENCRYPTION_KEY environment variable.

**Alternatives Considered:**
1. **Database-level encryption (TDE)** - Rejected: Not available in Replit PostgreSQL, requires enterprise database
2. **No encryption** - Rejected: Security risk, fails compliance audits, industry anti-pattern
3. **Application-level AES-256-CBC** - Rejected: No authentication (GCM is better), susceptible to padding oracle attacks
4. **Third-party encryption service (AWS KMS)** - Rejected: External dependency, latency, cost, operational complexity

**Consequences:**
- **Positive:** 
  - Strong encryption (256-bit key)
  - Tamper detection via authenticated encryption
  - Node.js crypto module (no external dependencies)
  - Fast performance (<1ms per operation)
- **Negative:** 
  - ENCRYPTION_KEY loss = permanent data loss
  - Slight performance overhead (~0.5ms per encrypt/decrypt)
  - Key rotation requires data migration
- **Trade-off:** Security vs. operational complexity - acceptable for OAuth use case, industry standard practice

---

## 8. Security Architecture

### 8.1 Authentication Flow

**Registration:**
1. User submits email, password, full name
2. Validate email format, password strength (min 8 chars, 1 uppercase, 1 number)
3. Hash password with bcrypt (rounds=12)
4. Create user record, create default organization
5. Generate JWT token (24h expiry)
6. Return token and user profile

**Login:**
1. User submits email, password
2. Query user by email
3. Compare password with bcrypt.compare()
4. Generate JWT token with user ID, organization ID, role
5. Return token and user profile

**Logout:**
1. Client discards JWT token
2. Server has no state to clear (stateless JWT)

**Password Reset:**
1. User submits email via "Forgot Password"
2. Generate random reset token (32 bytes), hash with SHA-256
3. Store hashed token in database with 1-hour expiry
4. Send email with reset link containing plaintext token
5. User clicks link, submits new password + token
6. Verify token hash matches database, not expired
7. Update password, invalidate reset token
8. Send confirmation email

### 8.2 Authorization Model

**Organization Isolation:**
- Every request validates user belongs to organization
- All queries filter by `organizationId`
- Row-level security enforced in application layer

**Role-Based Access Control (RBAC):**

**Roles:**
- **Admin:** Full access (manage org, members, projects, integrations)
- **Editor:** Create/edit projects, run processing jobs, cannot manage members
- **Viewer:** Read-only access to projects and results

**Permission Matrix:**

| Action | Admin | Editor | Viewer |
|--------|-------|--------|--------|
| Create project | ✓ | ✓ | ✗ |
| Edit project | ✓ | ✓ | ✗ |
| Delete project | ✓ | ✗ | ✗ |
| Upload files | ✓ | ✓ | ✗ |
| Run processing | ✓ | ✓ | ✗ |
| View results | ✓ | ✓ | ✓ |
| Export datasets | ✓ | ✓ | ✓ |
| Manage integrations | ✓ | ✗ | ✗ |
| Invite members | ✓ | ✗ | ✗ |
| Remove members | ✓ | ✗ | ✗ |

**Middleware Implementation:**
```typescript
// Check user has required role
export function requireRole(...allowedRoles: Role[]) {
  return (req: Request, res: Response, next: NextFunction) => {
    const userRole = req.user.role;
    
    if (!allowedRoles.includes(userRole)) {
      return sendError(res, 403, 'FORBIDDEN', 'Insufficient permissions');
    }
    
    next();
  };
}

// Usage
router.delete('/projects/:id', requireAuth, requireRole('admin'), deleteProject);
```

### 8.3 Security Middleware

**Required Middleware (Constitution Section C):**
- `helmet` - Security headers (CSP, HSTS, etc.)
- `cors` - CORS configuration (Replit domains + localhost)
- `express-rate-limit` - Rate limiting per IP/user
- `morgan` - Request logging

**Additional Security:**
- `express-validator` - Input validation and sanitization
- `hpp` - HTTP Parameter Pollution protection

**Configuration:**
```typescript
// Helmet
app.use(helmet({
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'", "'unsafe-inline'"], // Vite dev server
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
    },
  },
}));

// CORS
app.use(cors({
  origin: [
    'http://localhost:5173', // Vite dev
    process.env.REPLIT_ORIGIN!, // Replit production
  ],
  credentials: true,
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // Limit each IP to 100 requests per windowMs
  standardHeaders: true,
  legacyHeaders: false,
});
app.use('/api/', limiter);

// Stricter limit for auth endpoints
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 5, // 5 login attempts per 15 minutes
});
app.use('/api/auth/login', authLimiter);
```

### 8.4 Input Validation

**Strategy:** Validate all inputs at API boundary using express-validator

**Example:**
```typescript
const validateProject = [
  body('name').trim().isLength({ min: 1, max: 100 }).escape(),
  body('description').optional().trim().isLength({ max: 500 }).escape(),
  body('schemaType').isIn(['conversation', 'knowledge_base']),
];

router.post('/projects', requireAuth, validateProject, async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return sendError(res, 400, 'VALIDATION_ERROR', 'Invalid input', errors.array());
  }
  // ... create project
});
```

### 8.5 File Upload Security

**Virus Scanning:**
- Use ClamAV (local) or VirusTotal API (cloud)
- Scan before moving from /tmp to S3
- Block upload if virus detected

**File Type Validation:**
- Whitelist: CSV, JSON, XML, XLSX
- Validate MIME type AND file extension
- Parse file header to verify actual format

**Size Limits:**
- Max file size: 100MB per upload
- Configured in multer middleware
- Return 413 Payload Too Large if exceeded

**Storage Isolation:**
- Each organization has S3 prefix: `org-{orgId}/`
- Prevent path traversal attacks
- Validate S3 keys before access

---

## 9. Data Architecture Overview

### 9.1 Data Flow

**Ingestion → Processing → Storage:**

1. **Source Data:** User uploads file or connects Teamwork Desk
2. **Raw Storage:** Files stored in S3 (`raw/{orgId}/{fileId}`)
3. **Processing:** In-memory transformation pipeline
4. **Metadata:** Job status, configuration, logs in PostgreSQL
5. **Output Storage:** Processed datasets in S3 (`exports/{orgId}/{jobId}`)
6. **Access:** Download URLs generated with expiry (24h)

### 9.2 Storage Strategy

**PostgreSQL:**
- User accounts and authentication
- Organization and team data
- Project configuration
- Job metadata and progress
- Encrypted OAuth tokens
- Schema definitions
- Audit logs

**S3 Storage:**
- Raw uploaded files (30-day retention)
- Processed dataset exports (30-day retention)
- Temporary processing files (deleted after job completion)

**Retention Policy:**
- Raw files: 30 days from upload
- Exports: 30 days from generation
- Database: Indefinite (with backups)

### 9.3 Caching Strategy

**Database Connections:**
- Connection pool with max 10 connections
- Caching enabled in postgres-js driver
- Keep-alive to reduce connection overhead

**API Responses:**
- No caching for MVP (all data dynamic)
- Consider adding later for: organization settings, schema definitions

**S3 Presigned URLs:**
- Generate with 24-hour expiry
- Cache URL in database for reuse within expiry window

---

## 10. Third-Party Integrations

### 10.1 Teamwork Desk Integration

**Classification:** OPTIONAL (MVP feature, not required for core functionality)

**API Type:** REST API with OAuth 2.0

**Authentication:**
- OAuth 2.0 Authorization Code flow
- Scopes: `read:tickets`, `read:conversations`
- Token refresh supported

**Rate Limits:**
- 120 requests per minute (per Teamwork documentation)
- Implement exponential backoff on 429 responses

**Endpoints Used:**
- GET `/desk/v1/tickets.json` - List tickets
- GET `/desk/v1/tickets/{id}.json` - Get ticket details
- GET `/desk/v1/tickets/{id}/conversations.json` - Get conversations

**Cost:** Free for users with existing Teamwork account

**Failure Modes:**
- OAuth token expired → Refresh token flow
- Rate limit exceeded → Wait with exponential backoff
- API unavailable → Display error, allow retry
- Invalid credentials → Disconnect integration, notify user

**Fallback:** Users can still upload CSV exports from Teamwork instead of API integration

### 10.2 S3-Compatible Storage

**Classification:** REQUIRED (core functionality depends on persistent file storage)

**API Type:** S3-compatible REST API (AWS SDK)

**Authentication:** Access Key ID + Secret Access Key (stored in environment variables)

**Recommended Providers:**
1. **Cloudflare R2** - Zero egress fees, S3-compatible, $0.015/GB storage
2. **Backblaze B2** - Low cost, S3-compatible, $0.005/GB storage
3. **AWS S3** - Industry standard, higher cost, $0.023/GB + egress

**Rate Limits:** 
- Cloudflare R2: 1000 requests/second
- Backblaze B2: 100 requests/second
- AWS S3: 5500 GET/second, 3500 PUT/second

**Cost Estimate (1000 active users, 50GB storage):**
- Cloudflare R2: ~$0.75/month (storage only)
- Backblaze B2: ~$0.25/month + egress
- AWS S3: ~$1.15/month + egress

**Failure Modes:**
- Upload fails → Retry with exponential backoff (3 attempts)
- Download fails → Generate new presigned URL
- Service unavailable → Queue for retry, notify user

**Fallback:** None (critical dependency), display maintenance message if unavailable

### 10.3 Resend Email Service

**Classification:** OPTIONAL (emails can be logged to console, integration not critical for MVP)

**API Type:** REST API with API key authentication

**Authentication:** API Key (stored in environment variable)

**Rate Limits:** 
- Free tier: 100 emails/day, 3000 emails/month
- Paid tier: 50,000 emails/month starting at $20/month

**Endpoints Used:**
- POST `/emails` - Send email

**Email Types:**
- Welcome email (registration)
- Password reset
- Team invitation
- Processing job completed notification

**Cost:** Free tier sufficient for MVP (<100 users)

**Failure Modes:**
- API unavailable → Log to console, continue operation
- Rate limit exceeded → Queue for retry, log warning
- Invalid API key → Gracefully degrade, log to console

**Fallback:** Log emails to console in development, gracefully degrade in production (user can still use app)

### 10.4 PII Detection (compromise.js)

**Classification:** REQUIRED (core feature)

**Type:** npm package (local dependency)

**Authentication:** None (open source library)

**Cost:** Free (MIT license)

**Version:** compromise@14.x (latest stable)

**Size:** ~100KB (minified)

**Failure Modes:**
- Library error → Log error, skip PII detection for that record, continue processing
- Memory exhaustion → Process in batches of 1000 records

**Fallback:** Custom regex patterns only (deterministic, no ML)

---

## 11. Replit Deployment Configuration

### 11.1 .replit File

```toml
run = "npm run start"
entrypoint = "server/index.ts"

[nix]
channel = "stable-23_11"

[deployment]
run = ["npm", "run", "start"]
deploymentTarget = "cloudrun"
ignorePorts = false

[[ports]]
localPort = 5000
externalPort = 80

[env]
NODE_ENV = "production"
PORT = "5000"
```

### 11.2 Environment Variables

**Required (Production Deployment Blockers):**

```bash
# Database (provided by Replit)
DATABASE_URL=postgresql://...

# JWT Authentication
JWT_SECRET=[64 random characters]  # Generate: openssl rand -base64 48

# Encryption (for OAuth tokens)
ENCRYPTION_KEY=[64 hex characters]  # Generate: node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"

# External Storage (S3-compatible)
S3_ENDPOINT=https://...
S3_BUCKET=foundry-production
S3_ACCESS_KEY_ID=...
S3_SECRET_ACCESS_KEY=...
S3_REGION=auto  # For Cloudflare R2

# Application
BASE_URL=https://your-repl-name.repl.co
```

**Optional (Graceful Degradation):**

```bash
# Email Service (Resend)
RESEND_API_KEY=re_...  # If not set, emails logged to console

# Teamwork Desk OAuth
TEAMWORK_CLIENT_ID=...
TEAMWORK_CLIENT_SECRET=...
TEAMWORK_REDIRECT_URI=https://your-repl-name.repl.co/api/integrations/teamwork/callback
# If not set, Teamwork integration feature disabled

# Monitoring (optional)
LOG_LEVEL=info  # debug, info, warn, error
```

**Development (Local):**

```bash
# Database (use Replit connection or local PostgreSQL)
DATABASE_URL=postgresql://localhost:5432/foundry_dev

# JWT Authentication (use test secret)
JWT_SECRET=test-secret-do-not-use-in-production

# Encryption (use test key)
ENCRYPTION_KEY=0000000000000000000000000000000000000000000000000000000000000000

# External Storage (use local MinIO or test credentials)
S3_ENDPOINT=http://localhost:9000
S3_BUCKET=foundry-dev
S3_ACCESS_KEY_ID=minioadmin
S3_SECRET_ACCESS_KEY=minioadmin
S3_REGION=us-east-1

# Application
BASE_URL=http://localhost:5173
NODE_ENV=development
PORT=5000
```

### 11.3 Port Configuration

**Production (Replit):**
- Port 5000 (internal)
- Port 80 (external via Replit proxy)
- Single port exposed via .replit configuration

**Development (Local):**
- Backend: Port 5000
- Frontend: Port 5173 (Vite default)
- Vite proxies API requests to backend

**Vite Proxy Configuration:**
```typescript
// vite.config.ts
export default defineConfig({
  server: {
    port: 5173,
    proxy: {
      '/api': {
        target: 'http://localhost:5000',
        changeOrigin: true,
      },
    },
  },
});
```

### 11.4 Build Configuration

**Production Build:**
```bash
# Install dependencies
npm ci

# Build frontend
npm run build

# Start production server (serves static frontend + API)
npm run start
```

**Scripts (package.json):**
```json
{
  "scripts": {
    "dev": "concurrently \"npm run dev:server\" \"npm run dev:client\"",
    "dev:server": "tsx watch server/index.ts",
    "dev:client": "vite",
    "build": "vite build",
    "start": "NODE_ENV=production tsx server/index.ts",
    "db:generate": "drizzle-kit generate:pg",
    "db:migrate": "tsx server/db/migrate.ts",
    "db:seed": "tsx server/db/seed.ts"
  }
}
```

**Static File Serving:**
```typescript
// server/index.ts
if (process.env.NODE_ENV === 'production') {
  app.use(express.static(path.join(__dirname, '../dist')));
  
  // Serve index.html for all non-API routes (SPA routing)
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, '../dist/index.html'));
  });
}
```

---

## 12. Architecture Decision Records

### ADR-002: Monolithic Architecture for MVP

**Context:** Foundry MVP requires rapid development and deployment on Replit's single-container platform. Team size is small (1-3 developers), and scale expectations are modest (50-200 organizations).

**Decision:** Implement monolithic architecture with frontend (React SPA) and backend (Express API) in single repository and deployment.

**Alternatives Considered:**
1. **Microservices** - Rejected: Operational complexity exceeds team capacity, Replit single-container model incompatible, premature optimization
2. **Serverless (Lambda/Vercel)** - Rejected: Replit deployment target specified, stateful processing job requirements
3. **Backend-for-Frontend (BFF)** - Rejected: Unnecessary layer for direct client-API communication

**Consequences:**
- **Positive:** Simple deployment, shared code (TypeScript types), atomic releases, easier debugging, no service mesh complexity
- **Negative:** Vertical scaling only, potential deployment coupling, larger codebase
- **Trade-off:** Simplicity vs. scalability - acceptable for MVP, revisit at 1000+ organizations

### ADR-003: In-Process Job Queue vs. External Queue Service

**Context:** Foundry processes datasets asynchronously with progress tracking. Processing time ranges from 5 seconds (small CSV) to 30 minutes (100k records with PII detection).

**Decision:** Implement in-process job queue backed by PostgreSQL database, with single worker polling for pending jobs.

**Alternatives Considered:**
1. **Bull/BullMQ with Redis** - Rejected: Redis not available on Replit free tier, adds operational complexity (Redis management, connection handling)
2. **AWS SQS or Google Cloud Tasks** - Rejected: External dependency increases latency, monthly cost (~$10-50), requires AWS/GCP account management
3. **Database-only with polling** - Chosen: Simplest implementation, reliable, sufficient for MVP scale

**Consequences:**
- **Positive:** Zero external dependencies, atomic job state updates, simple debugging, no message broker failure modes
- **Negative:** Single worker (no horizontal scaling), polling overhead (~5MB database queries/minute), job distribution complexity if adding workers
- **Trade-off:** Simplicity vs. scalability - acceptable for MVP (10-50 concurrent jobs max), database-backed queue enables future migration to Bull/SQS

**Migration Path:** If >100 concurrent jobs required, add Redis and migrate to Bull queue with same database schema for job state persistence.

### ADR-004: S3-Compatible Storage for Files

**Context:** Replit uses ephemeral filesystem that resets on container restart. Foundry stores uploaded files (30-day retention) and generated datasets (30-day retention). Files range from 1KB (small JSON) to 100MB (large CSV).

**Decision:** Use S3-compatible object storage (Cloudflare R2 recommended) for all file persistence.

**Alternatives Considered:**
1. **Database BYTEA storage** - Rejected: Poor performance for large files (100MB), expensive ($10+/GB), backup complexity
2. **Self-hosted MinIO on separate server** - Rejected: Requires server management, cost ($10-20/month minimum), operational overhead
3. **Replit ephemeral storage** - Rejected: Files lost on restart, no persistence guarantee

**Consequences:**
- **Positive:** Reliable persistence, scalable storage (unlimited), industry-standard API, cost-effective ($0.75/month for 50GB)
- **Negative:** External dependency, network latency (50-200ms), requires account management
- **Trade-off:** Reliability vs. external dependency - mandatory for production, cost justifiable ($0.015/GB)

**Provider Recommendation:** Cloudflare R2 (zero egress fees) > Backblaze B2 (lowest storage cost) > AWS S3 (highest cost)

### ADR-005: Lightweight PII Detection (compromise.js + regex)

**Context:** Foundry detects PII in text data to enable redaction before AI training. PRD requires detection of: names, emails, phone numbers, SSNs, credit cards. Processing 100k records must complete in <30 minutes.

**Decision:** Use compromise.js (lightweight NER) combined with custom regex patterns for deterministic PII detection.

**Alternatives Considered:**
1. **Microsoft Presidio** - Rejected: Python dependency (requires Python runtime in Node.js app), complex deployment, 50MB+ library size
2. **AWS Comprehend PII** - Rejected: External API cost ($0.001/100 chars = $10-100/job), latency (2-5s per request), monthly billing
3. **spaCy.js** - Rejected: Large model size (100MB+), slow initialization (5-10s), memory intensive (200MB+ RAM)
4. **No PII detection** - Rejected: Core feature requirement, privacy risk

**Consequences:**
- **Positive:** Fast performance (<100ms per record), no external API, no Python runtime, small footprint (100KB), deterministic patterns (emails, phones, SSNs)
- **Negative:** Lower accuracy vs. ML models (85-90% vs. 95%+), limited entity types (PERSON, ORG, LOCATION), may miss complex cases
- **Trade-off:** Performance vs. accuracy - acceptable for MVP, add ML model post-MVP if accuracy insufficient

**Accuracy Target:** 85-90% detection rate with <5% false positive rate. Instrument detection accuracy during beta testing.

### ADR-006: JWT Authentication vs. Session Cookies

**Context:** Foundry requires user authentication for multi-tenant SaaS. Users access from web browsers and potentially mobile apps in future. Sessions must survive server restarts.

**Decision:** Use JWT (JSON Web Tokens) with 24-hour expiry for authentication.

**Alternatives Considered:**
1. **Session cookies with Redis** - Rejected: Redis not available on Replit free tier, adds external dependency
2. **Session cookies with database** - Rejected: Database query on every request, stateful sessions complicate horizontal scaling
3. **Third-party auth (Auth0, Clerk)** - Rejected: External dependency, monthly cost ($25-100), overkill for MVP

**Consequences:**
- **Positive:** Stateless authentication, no session storage, mobile-friendly, enables future API access, standard protocol
- **Negative:** Token revocation complexity (requires blacklist), larger payload vs. session ID, token refresh not implemented in MVP
- **Trade-off:** Stateless vs. revocation - acceptable for MVP (24h expiry limits exposure), revisit if immediate logout required

**JWT Payload:**
```json
{
  "userId": "123",
  "organizationId": "456",
  "role": "admin",
  "iat": 1706745600,
  "exp": 1706832000
}
```

### ADR-007: Response Envelope Standardization

**Context:** Inconsistent API response structures cause frontend integration failures. Previous projects experienced: pagination bugs (frontend assumed flat array, backend returned envelope), error handling failures (no machine-readable error codes), and missing request IDs for debugging.

**Decision:** Mandate standardized response envelopes for all API responses: success (`{data, meta}`), paginated (`{data, meta.pagination}`), and error (`{error, meta}`).

**Alternatives Considered:**
1. **No standard envelope** - Rejected: Causes frontend integration failures, inconsistent error handling, debugging difficulties
2. **Flat responses with HTTP headers** - Rejected: Difficult to access pagination in client, no JSON error details
3. **GraphQL** - Rejected: Overkill for REST CRUD API, adds complexity

**Consequences:**
- **Positive:** Consistent frontend integration, predictable error handling, built-in request tracing, pagination standardized
- **Negative:** Slightly larger payloads (~30 bytes overhead), requires discipline to use helpers
- **Trade-off:** Consistency vs. payload size - strongly positive (30 bytes negligible, prevents hours of debugging)

**Enforcement:** Mandatory response helper functions (`sendSuccess`, `sendCreated`, `sendPaginated`, `sendNoContent`) - no direct `res.json()` calls allowed.

---

## 13. Document Validation

### 13.1 Completeness Checklist

- [x] All PRD features have architectural support
  - Multi-format file ingestion: S3 storage + parsing library
  - Schema mapping: Database schema + processing engine
  - PII detection: compromise.js + regex patterns
  - OAuth integration: Encrypted token storage
  - Multi-tenancy: Organization-based isolation + RBAC
  - Real-time progress: Job polling endpoint
  
- [x] Technology stack complete with rationale
  - Frontend: React + TypeScript + Vite + shadcn/ui
  - Backend: Express.js + TypeScript
  - Database: PostgreSQL + Drizzle ORM
  - Storage: S3-compatible (Cloudflare R2)
  - Email: Resend
  - PII: compromise.js
  - Auth: JWT + bcrypt
  
- [x] Auth flows fully specified
  - Registration, login, logout
  - Password reset with email token
  - JWT token generation (24h expiry)
  - RBAC with 3 roles (Admin, Editor, Viewer)
  
- [x] Integrations classified (required/optional)
  - REQUIRED: S3 storage, PostgreSQL, PII detection library
  - OPTIONAL: Resend email, Teamwork Desk OAuth
  
- [x] Replit configuration complete
  - .replit file with port 5000
  - Environment variables (required vs. optional)
  - Build and start scripts
  - Static file serving for SPA
  
- [x] Security middleware specified
  - helmet (security headers)
  - cors (CORS configuration)
  - express-rate-limit (rate limiting)
  - morgan (request logging)
  - express-validator (input validation)
  
- [x] Response envelope specification included
  - Success, paginated, error structures defined
  - Helper functions specified (sendSuccess, sendCreated, sendPaginated, sendNoContent)
  - Enforcement strategy documented
  
- [x] Sensitive data encryption specification (OAuth tokens)
  - AES-256-GCM algorithm specified
  - Encryption utility implementation provided
  - Key management strategy documented
  - Usage patterns with code examples
  - Zero-tolerance rule for TODO comments
  
- [x] Minimum 5 ADRs documented
  - ADR-001: Sensitive Data Encryption
  - ADR-002: Monolithic Architecture
  - ADR-003: In-Process Job Queue
  - ADR-004: S3-Compatible Storage
  - ADR-005: Lightweight PII Detection
  - ADR-006: JWT Authentication
  - ADR-007: Response Envelope Standardization

### 13.2 Audit Prevention Summary

This Architecture addresses 2 common production issues identified in Agent 2 framework:

**HIGH-001: Sensitive Data Encryption**
- **Issue:** OAuth tokens stored in plaintext enable account takeover if database compromised
- **Prevention:** AES-256-GCM encryption mandated for all OAuth tokens and API keys
- **Implementation:** Full encryption utility specification with key management strategy
- **Enforcement:** Zero-tolerance rule for TODO/FIXME in encryption code paths

**MED-001: Response Envelope Inconsistency**
- **Issue:** Inconsistent API response structures cause frontend integration failures
- **Prevention:** Standardized response envelopes mandated for all endpoints
- **Implementation:** Helper functions (sendSuccess, sendCreated, sendPaginated, sendNoContent)
- **Enforcement:** No direct `res.json()` calls allowed, code review checklist includes compliance

### 13.3 Prompt Hygiene Gate (Constitution Section L)

- [x] Framework Version header present and correct
  - Framework: Agent Specification Framework v2.1
  - Constitution: Agent 0 - Agent Constitution v3.3
  
- [x] Encoding scan: No non-ASCII artifact tokens
  - Document scanned, no encoding issues detected
  
- [x] Inheritance references Constitution v3.3
  - Referenced in: Authority Scope, Constraint Extraction, Downstream Handoff
  - No full global rule restatements (uses "Per Constitution Section X")
  
- [x] No full global rule restatements
  - Health endpoints: "Per Constitution Section C"
  - Database configuration: "Per Constitution Section D"
  - Response envelopes: "Per Constitution Section C"
  - Security middleware: "Per Constitution Section C"

### 13.4 Confidence Scores

| Section | Score (1-10) | Notes |
|---------|--------------|-------|
| Technology Stack | 9 | All choices validated against Replit constraints, minor risk: PII accuracy (85-90%) |
| Security Architecture | 9 | Encryption specified, JWT standard, RBAC clear; refresh tokens deferred to post-MVP |
| Processing Architecture | 8 | In-process queue sufficient for MVP, may need Bull/Redis at scale (>100 jobs) |
| API Architecture | 10 | Response envelopes standardized, RESTful design, health endpoints specified |
| Deployment Configuration | 9 | Replit-specific configuration complete, environment variables classified |
| ADR Quality | 9 | 7 ADRs with context/alternatives/consequences, trade-offs explicit |
| Overall Completeness | 9 | All PRD requirements mapped, encryption + response envelopes mandated |

**Risks Identified:**
1. **Processing timeout** (30 min) may be insufficient for 100k+ records with complex PII detection → Solution: Instrument actual performance, add streaming if needed
2. **PII detection accuracy** (85-90%) may have false negatives → Solution: Add ML model post-MVP if beta testing shows inadequate accuracy
3. **Single worker** limits concurrency → Solution: Migrate to Bull/Redis queue if >100 concurrent jobs required

### 13.5 Document Status: COMPLETE

All required sections present, all checkpoints passed, all ADRs documented, encryption and response envelope specifications mandated.

---

## 14. Downstream Agent Handoff Brief

### 14.1 Global Platform Context (All Agents)

**Per Constitution Section C:**
- Standard response envelopes: `{data, meta}` for success, `{error, meta}` for errors
- Health endpoint format: `/health` returns `{status, timestamp, uptime, dependencies}`
- JWT authentication: Bearer tokens, 24h expiry, bcrypt password hashing
- API conventions: RESTful URLs, HTTP verbs, status codes

**Per Constitution Section D:**
- Replit platform: Port 5000, ephemeral filesystem, single container
- Database: PostgreSQL with postgres-js driver (mandated)
- ORM: Drizzle ORM Core Select API only (mandated)
- Connection: Pool with caching enabled, max 10 connections

### 14.2 Agent 3: Data Modeling

**Database:**
- PostgreSQL 14+ via Replit managed DB
- Driver: postgres-js (Constitution mandated)
- ORM: Drizzle ORM Core Select API only
- Connection: Pool with caching enabled

**Key Entities Implied by Architecture:**
- `users` - User accounts, authentication
- `organizations` - Multi-tenant organizations
- `projects` - Data preparation projects
- `files` - Uploaded source files (metadata, S3 references)
- `jobs` - Processing jobs with status and progress
- `integrations` - OAuth integrations (Teamwork Desk)
- `schemas` - Canonical schema definitions
- `mappings` - Schema mapping configurations

**CRITICAL - Encrypted Columns:**
- `integrations.access_token` - TEXT type, stores encrypted hex string (format: `iv:encrypted:authTag`)
- `integrations.refresh_token` - TEXT type, stores encrypted hex string
- Storage size: ~100-200 chars per encrypted token

**Multi-Tenancy:**
- All tables include `organization_id` foreign key
- Row-level security enforced in application layer
- Queries filtered by organization_id

**Relationships:**
- User → Organization (many-to-one, single org per user in MVP)
- Project → Organization (many-to-one)
- File → Project (many-to-one)
- Job → Project (many-to-one)
- Integration → Organization (many-to-one, one Teamwork per org)

**Indexes Required:**
- `users.email` (unique, for login)
- `users.organization_id` (for multi-tenancy queries)
- `projects.organization_id` (for project listing)
- `jobs.status` (for queue polling)
- `jobs.project_id` (for job history)

**Timestamps:**
- All entities: `created_at`, `updated_at` (auto-managed)
- ISO 8601 format in API responses

### 14.3 Agent 4: API Contract

**Framework:** Express.js + TypeScript

**CRITICAL - Response Envelopes:**
Use response helper functions defined in Architecture Section 6. **NO** direct `res.json()` calls.

**Helper Functions (MANDATORY):**
- `sendSuccess(res, data)` - 200 OK with `{data, meta}`
- `sendCreated(res, data)` - 201 Created with `{data, meta}`
- `sendPaginated(res, data, pagination)` - 200 OK with `{data, meta.pagination}`
- `sendNoContent(res)` - 204 No Content

**Example Usage:**
```typescript
// Success
return sendSuccess(res, { id: project.id, name: project.name });

// Paginated
return sendPaginated(res, projects, { page: 1, pageSize: 20, total: 42 });
```

**Authentication:**
- JWT Bearer tokens (Authorization header)
- Token payload: `{userId, organizationId, role}`
- Middleware: `requireAuth` (validate token, attach user to req)
- Authorization: `requireRole(...roles)` (check user role)

**Error Responses:**
All errors use `{error, meta}` envelope with:
- `error.code` - Machine-readable (e.g., "INVALID_FILE_FORMAT")
- `error.message` - Human-readable
- `error.details` - Optional additional context

**Pagination:**
- Page-based (not cursor-based in MVP)
- Query params: `page` (default: 1), `pageSize` (default: 20, max: 100)
- Response includes: `page`, `pageSize`, `total`, `totalPages`, `hasMore`

**File Upload:**
- Use multer middleware for multipart/form-data
- Max size: 100MB
- Allowed types: CSV, JSON, XML, XLSX
- Validate MIME type and extension

**Core Endpoints (from Architecture Section 4):**
- Auth: `/api/auth/register`, `/api/auth/login`, `/api/auth/logout`, etc.
- Projects: `/api/projects`, `/api/projects/:id`
- Files: `/api/files/upload`, `/api/files/:id`
- Jobs: `/api/jobs`, `/api/jobs/:id`
- Integrations: `/api/integrations/teamwork/*`
- Health: `/health`

### 14.4 Agent 5: UI/UX Specification

**Framework:** React 18 + TypeScript + Vite

**Component Library:** shadcn/ui (copy-paste components, customizable)

**Styling:** Tailwind CSS with CSS variables for theming

**Icons:** Lucide React

**Routing:** React Router v6

**Key UI Patterns:**
- File upload: Drag-and-drop with progress bar
- Schema mapping: Visual column mapper (source → target)
- Processing monitor: Real-time progress with polling
- Data preview: Infinite-scroll table
- Configuration wizards: Multi-step forms

**Accessibility:** WCAG 2.1 AA compliance
- Keyboard navigation for drag-and-drop
- Screen reader announcements for progress
- Form validation errors semantically linked

**Responsive:** Desktop-first, tablets supported, mobile shows "Desktop recommended"

**API Integration:**
- Axios or fetch for HTTP requests
- JWT token in Authorization header
- Response envelopes: `data` field for success, `error` field for errors
- Pagination: `meta.pagination` field

### 14.5 Agent 6: Implementation Orchestrator

**Security Middleware (MANDATORY):**
- `helmet` - Security headers (CSP, HSTS, etc.)
- `cors` - CORS configuration (Replit origin + localhost)
- `express-rate-limit` - Rate limiting per IP (100 req/15min), auth endpoints (5 req/15min)
- `morgan` - Request logging

**Critical Configuration:**
- Port 5000 (Replit exposed port)
- Trust proxy (for rate limiting and IP detection behind Replit proxy)
- Vite watch ignored directories: `node_modules`, `.git`, `dist`

**File Upload Specifics:**
- Multer middleware for multipart/form-data
- Temporary storage: `/tmp` directory (ephemeral)
- Final storage: S3-compatible external storage
- Virus scanning: ClamAV or VirusTotal before moving to S3

**Processing Architecture:**
- Simple queue in MVP (database-backed, no distributed job runner)
- In-process worker polling for pending jobs (every 5 seconds)
- Timeout: 30 minutes per processing job
- Graceful shutdown: Finish current job, mark others as pending

**External Dependencies:**
- AWS SDK (or compatible): For S3 file storage (REQUIRED)
- compromise.js: For PII detection NER (REQUIRED)
- Custom regex: For deterministic PII patterns (email, phone, SSN) (REQUIRED)
- Resend SDK: For email service (OPTIONAL)
- ClamAV or VirusTotal: For virus scanning (REQUIRED)

**MANDATORY Files:**
- `server/lib/response.ts` - Response helper functions (sendSuccess, sendCreated, sendPaginated, sendNoContent)
- `server/lib/encryption.ts` - Encryption utility (encrypt, decrypt, generateEncryptionKey)
- `server/lib/pii.ts` - PII detection (compromise.js + regex patterns)
- `server/lib/validation.ts` - Input validation helpers (express-validator)
- `server/middleware/auth.ts` - Authentication middleware (requireAuth, requireRole)

**Route Registration Order:**
- Specific routes before parameterized routes
- Example: `/api/jobs/pending` before `/api/jobs/:id`

**Graceful Shutdown Handler:**
```typescript
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, closing gracefully...');
  await closeDatabase();
  await closeS3Client();
  process.exit(0);
});
```

### 14.6 Agent 7: QA & Deployment

**Health Endpoint Format (Constitution Section C):**
```json
{
  "status": "healthy",
  "timestamp": "2026-01-21T10:30:00Z",
  "uptime": 3600,
  "dependencies": {
    "database": "healthy",
    "storage": "healthy",
    "email": "healthy"
  }
}
```

**Deployment Verification Checklist:**
1. Environment variables set (DATABASE_URL, JWT_SECRET, ENCRYPTION_KEY, S3 credentials)
2. Database migrations applied
3. Health endpoint returns 200 OK
4. Test file upload → S3 storage
5. Test encryption/decryption (sample OAuth token)
6. Test JWT authentication (login → protected endpoint)
7. Test processing job (small CSV file)

**CRITICAL Verification:**
- **NO** direct `res.json()` calls in route handlers (all use response helpers)
- **NO** plaintext storage of OAuth tokens (all encrypted before DB insert)
- **NO** TODO/FIXME comments in encryption code paths
- **YES** ENCRYPTION_KEY environment variable set (64 hex chars)

**Common Issues:**
- Port mismatch: Must use 5000
- CORS errors: Check Replit origin in CORS config
- Database connection: Verify DATABASE_URL format
- S3 errors: Check credentials and bucket permissions
- Encryption errors: Verify ENCRYPTION_KEY length (64 hex chars)

---

## ASSUMPTION REGISTER

### AR-001: External File Storage Required

- **Type:** DEPENDENCY
- **Source Gap:** PRD acknowledges Replit's ephemeral filesystem but doesn't specify storage provider
- **Assumption Made:** Production requires S3-compatible storage (Cloudflare R2 recommended) for uploaded files (30-day retention) and exports (30-day retention)
- **Impact if Wrong:** Files lost on container restart, users cannot re-process datasets, MVP unusable in production
- **Proposed Resolution:** Architecture specifies S3-compatible storage with provider recommendations (Cloudflare R2 > Backblaze B2 > AWS S3). Human must select provider and configure credentials.
- **Status:** RESOLVED (Architecture specifies S3-compatible storage)
- **Owner:** Agent 2 (Architecture) → Human (provider selection)
- **Date:** 2026-01-21

### AR-002: PII Detection Library Selection

- **Type:** DEPENDENCY
- **Source Gap:** PRD mentions "PII detection" but doesn't specify detection method or library
- **Assumption Made:** compromise.js (lightweight NER) + custom regex patterns provide sufficient accuracy (85-90%) for MVP
- **Impact if Wrong:** Inaccurate PII detection causes privacy violations or excessive false positives breaking datasets
- **Proposed Resolution:** Architecture specifies compromise.js + regex patterns. Instrument detection accuracy during beta testing. Add ML model (spaCy, Presidio) post-MVP if accuracy insufficient.
- **Status:** RESOLVED (Architecture specifies compromise.js + regex)
- **Owner:** Agent 2 (Architecture) → Agent 6 (Implementation) for instrumentation
- **Date:** 2026-01-21

### AR-003: Email Service for Transactional Emails

- **Type:** DEPENDENCY
- **Source Gap:** PRD mentions "invitation emails" and "password reset" but doesn't specify email service
- **Assumption Made:** Resend provides best DX and cost-effectiveness for transactional emails, with graceful degradation if unavailable
- **Impact if Wrong:** Emails not delivered, users cannot reset passwords or accept invitations (mitigated: can manually send invites, password reset via admin)
- **Proposed Resolution:** Architecture specifies Resend with fallback to console logging. Email functionality OPTIONAL in MVP.
- **Status:** RESOLVED (Architecture specifies Resend with graceful degradation)
- **Owner:** Agent 2 (Architecture)
- **Date:** 2026-01-21

### AR-004: Single Organization per User

- **Type:** ASSUMPTION
- **Source Gap:** PRD doesn't explicitly state whether users can belong to multiple organizations
- **Assumption Made:** MVP: Users belong to exactly one organization (standard B2B SaaS pattern, reduces complexity)
- **Impact if Wrong:** Need junction table (users_organizations), auth context must track "current organization", UI needs org switcher (4-8 hours additional development)
- **Proposed Resolution:** Confirm with stakeholder: "Can a single user account belong to multiple organizations?" If yes, Agent 3 updates data model to many-to-many relationship.
- **Status:** UNRESOLVED (requires human confirmation)
- **Owner:** Human (Product stakeholder) → Agent 3 (Data Modeling if changes needed)
- **Date:** 2026-01-21

### AR-005: Teamwork Desk API Rate Limits

- **Type:** RISK
- **Source Gap:** PRD mentions Teamwork Desk integration but doesn't specify API rate limits or import behavior
- **Assumption Made:** Teamwork Desk API allows 120 requests/minute (per typical SaaS API limits), imports handled with exponential backoff on 429 responses
- **Impact if Wrong:** Imports fail or take excessively long if rate limits stricter than assumed (mitigated: exponential backoff handles any rate limit)
- **Proposed Resolution:** Verify Teamwork Desk API documentation during implementation. Architecture specifies exponential backoff strategy.
- **Status:** RESOLVED (Architecture specifies rate limit handling)
- **Owner:** Agent 6 (Implementation to verify actual limits)
- **Date:** 2026-01-21

### AR-006: Processing Timeout Strategy

- **Type:** ASSUMPTION
- **Source Gap:** PRD states "up to 15 minutes for 100k records" but doesn't specify timeout handling for larger datasets or edge cases
- **Assumption Made:** Processing timeout set to 30 minutes (2x expected max time), jobs exceeding timeout marked "failed" with partial results option
- **Impact if Wrong:** Users frustrated by timeout failures, or system resources exhausted by runaway jobs (mitigated: timeout prevents resource exhaustion)
- **Proposed Resolution:** Instrument processing times during beta testing. Architecture specifies 30-minute timeout. Adjust based on actual performance.
- **Status:** RESOLVED (Architecture specifies 30-minute timeout)
- **Owner:** Agent 7 (QA to monitor performance)
- **Date:** 2026-01-21

### AR-007: Conversation Schema is MVP-Only Schema

- **Type:** ASSUMPTION
- **Source Gap:** PRD mentions "canonical schemas" (plural) but only describes conversation use case in detail
- **Assumption Made:** MVP implements single canonical schema (conversation: message_id, role, message_text, timestamp, thread_id, metadata). Additional schemas (Q&A, knowledge base, decision records) are post-MVP.
- **Impact if Wrong:** Users wanting knowledge base or decision record schemas blocked, limited use cases (mitigated: single schema sufficient for primary persona Sarah Chen's use case)
- **Proposed Resolution:** Document post-MVP schema expansion path in roadmap. Architecture focuses on conversation schema.
- **Status:** ACCEPTED (Architecture focuses on conversation schema, post-MVP expansion documented)
- **Owner:** Human (Product roadmap)
- **Date:** 2026-01-21

### AR-008: 24-Hour Token Expiry Sufficient for MVP

- **Type:** ASSUMPTION
- **Source Gap:** Constitution defines 24h JWT expiry but doesn't consider long-running processing jobs or user workflow interruptions
- **Assumption Made:** 24h token expiry acceptable because processing completes in <30 minutes, user remains logged in during session
- **Impact if Wrong:** Users logged out during long data preparation sessions, frustrated by re-login interruptions (mitigated: processing <30min, frontend can refresh page without losing progress)
- **Proposed Resolution:** Monitor session expiry feedback during beta. Architecture specifies 24h expiry per Constitution. Consider refresh token pattern if complaints arise.
- **Status:** RESOLVED (Architecture follows Constitution 24h expiry, refresh tokens deferred)
- **Owner:** Agent 7 (QA to monitor user feedback)
- **Date:** 2026-01-21

---

## Document End
